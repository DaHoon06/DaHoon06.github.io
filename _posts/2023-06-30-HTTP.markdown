---
layout: post
title: HTTP
date: 2023-06-30 00:00:00 +0200
image: banner/network.png
tags: [HTTP]
categories: network
---


# HTTP(HyperText Transfer Protocol)
텍스트 기반 통신 규약으로 인터넷에서 데이터를 주고 받을 수 있는 프로토콜이다.

## HTTP 동작

사용자가 브라우저를 통해 어떠한 서비스를 URL을 통하거나 다른 것을 통해서 요청(Request)을 하면 서버에서는 해당 요청사항에 맞는 결과를 찾아서 응답(Response)하는 형태로 동작한다.
  
- 요청 Client -> Server
- 응답 Server -> Client

HTML 뿐만 아니라 Plain Text부터 JSON 데이터 및 XML 과 같은 형태의 정보도 주고 받을 수 있으며, 클라이언트가 어떤 정보를 HTML 형태로 받고 싶은지, JSON 형태로 받고 싶은지 명시해주는 경우가 많다.

## HTTP 특징

- HTTP 메세지는 HTTP 클라이언트와 HTTP 서버에 의해 해석된다.
- TCP / IP 를 이용하는 응용 프로토콜이다.
  (컴퓨터와 컴퓨터 간의 데이터를 전송할 수 있도록 하는 장치, 인터넷이라는 통신망을 통하여 원하는 정보[데이터]를 주고 받는 비연결성 프로토콜이다.)
- HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다.
  (상태를 유지하기 위해 Cookie 또는 Session과 같은 스토리지를 활용한다.)
- HTTP 연결을 유지하기 않는 프로토콜이기 때문에 요청 / 응답으로 동작한다.


---

# HTTP 1.0

- HTTP 1.0은 open / operation / close 방식을 취하는 단순한 구조이다.
- TCP Connection 하나 당 하나의 URL 만 fetch 하며, 매번 request / response 가 끝나면 연결이 끊기므로 필요할 때마다 다시 연결해야하는 단점이 있어 속도가 느리다.
- URL 의 크기가 작고 한번에 가져올 수 있는 데이터의 양이 제한되어 있다.

HTTP 1.0 에서는 open / close 를 위한 flow 의 제한으로 대역폭이 적게 할당되어 연결 되는데, 이로 인해 congestion information 이 자주 발생하고 disconnect가 반복적으로 나타난다.


반복되는 disconnect 현상으로 인해 한 서버에 계속해서 접속을 시도하게 되면 과부하가 걸리고 성능이 떨어지게 되는 문제가 발생한다.

---

# HTTP 1.1

## 가장 큰 특징

### 커넥션 유지 (Persistent Connection)

- 1.0 과 1.1의 차이는 TCP 세션을 지속적으로 유지할 수 있느냐 없느냐에 차이를 둔다.
  - 1.0은 매 요청마다 TCP 세션을 맺어야한다. (1 GET / 1 CONNECTION)
  - 1.1은 Persistent 기능을 이용하여 한 개의 TCP 세션을 통해 여러 개의 요청이 가능하다. (N GET / 1 CONNECTION)
### 파이프라이닝 (Pipelining)
  - 파이프라이닝을 통하여 여러 개의 요청을 한 번에 보낼 수 있다.

### 호스트 헤더 (Host Header)
  - 버츄얼 호스팅 (Virtual Hosring)   
    하나의 웹 서버에서 여러 개의 도메인을 호스팅할 수 있는 가상의 호스팅    
    
    HTTP 1.0 환경에서는 하나의 IP에 여러 개의 도메인 운영이 불가능하다.
      - 도메인 마다 IP를 구분해야함
### 강력한 인증 절차 (Improved Authentication Procedure)
  - 2 개의 헤더 추가
    - proxy-authentication
    - proxy-authorization

## 단점

### HOL (Head Of Line) Blocking - 특정 응답의 지연
어떤 요청에 병목이 발생하여 전체 latency가 증가   
TCP를 사용하는 통신에서 패킷은 무조건 정확한 순서대로 처리되어야한다.   
수신 측은 송신 측과 주고 받은 시퀀스 번호를 참고하여 패킷을 재 조립 해야하기 때문이다.    

중간에 패킷이 손실될 경우 완전한 데이터로 재조립하기 어렵기 때문에 송신 측은 해당 패킷이 제대로 전달되지 않았을 경우 재전송 해야한다.   

서버는 TCP 에서 요청을 받은 순서대로 응답을 해야하므로, 앞선 요청에 의해 뒤의 요청이 지연된다.    

### 무거운 Header

클라이언트-서버 간 많은 HTTP 요청이 발생할 것이고, header 의 정보는 대부분 동일하다.    
하지만 HTTP 1.1 에서는 header 를 중복해서 보낼 뿐만 아니라 cookie 정보 매 요청마다 header에 포함되어 전송된다.    

즉, 불필요한 데이터를 주고 받아 네트워크 자원이 소비되는 문제 발생